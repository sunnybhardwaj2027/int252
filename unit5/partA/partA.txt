HTTP METHODS + ROUTING(FULL STACK DEVELOPER LEVEL)

partA -> HTTP + Data fetching in React

1. what HTTP is(real web understanding)
2. GET, POST, PUT, DELETE
3. fetch() -> real usage
4. Axios -> when and why to use 
5. Async/await patterns
6. Error handling
7. Loading states
8. Debouncing + throttling for API calls
9. catching & re-fetch strategies
10. AbortController (cancelling requests)
11. Best folder structure(services/api.js)

1. what HTTP  really is(full stack understanding)
=> when your React app talks to backend(Node/Express), it does this:

React (Frontend) ---- HTTP Request ----> Node/Express (Backend)
React <---- HTTP Response ---- Server sends JSON

--- everything happens through "HTTP METHODS": ---

Method                     Purpose                      Example
GET                       fetch Data                    fetch all posts 
POST                      Create new Data               Add a user
PUT/PATCH                 Update existing data          Edit profile
DELETE                    Remove data                   Delete a todo

These map EXACTLY to CRUD operations

CRUD                                        HTTP Method
Create                                      POST
Read                                        GET
Update                                      PUT/PATCH
Delete                                      DELETE
=> this is the backbone of all full stack apps.

2. fetch()  --> the basic (but low-level) way

GET:

const res = await fetch("https://jsonplaceholder.typicode.com/posts"); => this is a pulic fake api which can work without backend set up.
const data = await res.json();

POST:

await fetch("/api/users", {
    method: "POST",
    headers: { "content-type": "application/json"},
    body: JSON.stringify( {name: "sunny" })
});

PUT: 

await fetch("/api/users/1", {
    method: "PUT",
    headers: { "content-type": "application/json" },
    body: JSON.stringify( {name : "Updated" } )
});

DELETE:

await fetch("/api/users/1", {
    method: "DELETE"
});


3. PROBLEMS WITH FETCH() => why real developer prefer axios => fetch is fine but very raw

  PROBLEM IN FETCH                                AXIOS SOLUTION
. No Automatic JSON parsing                       Axios auto-parses JSON
. No Automatic error handling                     Axios throws errors
. Need to manually set headers                    Axios sets them
. cancelling request is complex                   Axios has cancelToken
. large config objects                            Axios instance simlifies

4. AXIOS(INDUSTRY STANDARD)
=> install => npm install axios

GET:
const req = await axios.get("/api/users");
console.log(res.data);

POST:
await axios.post("/api/users", { name: "sunny" });

PUT: 
await axios.put("/api/users/1", { name: "new Name" });

DELETE:
await axios.delete("/api/users/1");

5. ERROR HANDLING(VERY IMPORTANT) => React developers handle API errors like this:

try {
    const res = await axios.get("/api/users");
    setUsers(res.data); 
} catch(err) {
    setError(err.message);
}

Always show:
Loading...
Error message
Retry button(optional)

6. AbortController (Senior level topic) => used to cancel request request when component unmount or user types again

Ex:

const controller = new AbortController();
fetch(url, { signal : controller.signal });

// cleanup
return () => controller.abort();

=> we will build a real search component later using this.

7. BEST PRACTICES STRUCTURE FOR APIs => never call fetch/axios directly inside components everywhere.

Create a folder  => src/services/api.js

write functions:

import axios from "axios";

export const getusers = () => axios.get("api/users");
export const createUser = (data) => axios.post("api/users", data);
export const updateUser = (id, data) => axios.put(`/api/users/${id}`, data);
export const deleteUser = (id) => axios.pus(`api/users/${id}`);

Then in components

useEffect(() => {
    getusers().then(res => setUsers(res.data));
}, []);

=> this is real full-stack architecture

✅ Step 1 → Axios + Error Handling + Loading UI (Deep Dive) => part2
✅ Step 2 → Routing (React Router v6) => part3
✅ Step 3 → Mini CRUD App (GET + POST + PUT + DELETE) => part4
✅ Step 4 → How React Frontend Talks to Node Backend (Full MERN Flow) => part5

