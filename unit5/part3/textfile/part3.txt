REACT ROUTER v6

SIMPLE -> ADVANCED (STEP-BY-STEP) is the perfect way to master React Router v6.
by the end, you will be able to build the routing for any real-world react app.

STEP 1=> Install React Router v6 => npm install react-router-dom

STEP 2=> create basic file structure => create a pages folder

src/
  pages/
    Home.jsx
    About.jsx
    Users.jsx


Each should export a simple component

Home.jsx

export default function Home() {
  return <h1>Home Page</h1>;
}

About.jsx

export default function About() {
  return <h1>About Page</h1>;
}

Users.jsx

export default function Users() {
  return <h1>Users Page</h1>;
}


STEP3 => Setup BrowserRouter in App.jsx
App.jsx(starting version)

import { BrowserRouter, Routes, Route } from "react-router-dom";
import Home from "./pages/Home";
import About from "./pages/About";
import Users from "./pages/Users";

function App() {
  return (
    <BrowserRouter>
      <Routes>

        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/users" element={<Users />} />

      </Routes>
    </BrowserRouter>
  );
}

export default App;

/ => shows Home
/about => shows About
/users => shows Users

STEP4 => Create Navigation (Links) => Add a navbar component (simple version)

Navbar.jsx

import { Link } from "react-router-dom";

export default function Navbar() {
  return (
    <nav style={{ display: "flex", gap: "20px", padding: "10px" }}>
      <Link to="/">Home</Link>
      <Link to="/about">About</Link>
      <Link to="/users">Users</Link>
    </nav>
  );
}

Now import it in App.jsx

import Navbar from "./Navbar";

function App() {
  return (
    <BrowserRouter>
      <Navbar />
      <Routes>
        ...
      </Routes>
    </BrowserRouter>
  );
}

=> Now you can click and navigate between pages
=> This creates a Single Page Application(No refresh)

STEP5 => useNavigate() => programmatic Navigation
=> inside any component (ex:- Home.jsx)

import { useNavigate } from "react-router-dom";

export default function Home() {
  const navigate = useNavigate();

  function goToUsers() {
    navigate("/users");
  }

  return (
    <>
      <h1>Home Page</h1>
      <button onClick={goToUsers}>Go to Users</button>
    </>
  );
}


=> Now clicking the button moves to '/users'
=> Commonly used after form Submit, login, etc.

STEP 6 => PASSING DATA THROUGH navigate()

you can pass state:

Home.jsx
navigate("/users", { state: { from : "home-page" }});

About.jsx
import { useLocation } from "react-router-dom";

export default function Users() {
  const location = useLocation();
  console.log(location.state);
  
  return <h1>Users Page</h1>;
}


=> used for redirects, notifications, protected routes, etc..

STEP 7 => 404 page not found

create:

NotFound.jsx
export default function NotFound() {
    return <h1>404 - Page Not Found<\h1>;
}


Add in App.jsx
<Route path="*" element={<NotFound />} />

=> Now wrong url shows 404 Page.

Now you officially have the foundation of React Router build.

Now we step into the REAL power of routing that full-stack develpers use.

STEP 2 => DYNAMIC ROUTES (/users/:id)

this is used almost every real app:

This is used in almost every real app:

. /products/23
. /users/5
. /blog/react-router-basics
. /orders/9229113

It's how you show details pages.

STEP 2.1 => CREATE A DYNAMIC ROUTE
in App.jsx => add this

import UserDetail from "./page/UserDetail"
import { BrowserRouter, Route, Routes } from "react-router-dom"

function App() {

  return (
    <>
      <BrowserRouter>
        <Routes>
          <Route path='/' element={<h1>Home Page - Try going to /users/1</h1>} />
          <Route path='/users/:id' element={ <UserDetail /> } />
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App

This means:

. /users/1 => UserDetail
. /users/5 => UserDetail
. /users/999 => UserDetail

STEP 2.2 => CREATE UserDetail.jsx page
create src/page/UserDetail.jsx

import { useParams } from "react-router-dom"

function UserDetail() {
  const { id } = useParams();

  return (
    <>
      <h1>User Detail Page</h1>
      <p>User ID: {id}</p>
    </>
  )
}

export default UserDetail

=> useParams() => gives you whatever is in the url

STEP 3 => NAVIGATE TO DYNAMIC ROUTE

create UserDetail2.jsx

import { Link } from "react-router-dom";

export default function UserDetail2() {
    const users = [
        { id: 1, name: "sunny"},
        { id: 2, name: "Rahul"},
        { id: 3, name: "Priya"}
    ]

    return (
        <div>
            <h1>Users Page</h1>

            <ul>
                {users.map((u) => (
                    <li key={u.id}>
                        <Link to={`/users2/${u.id}`}>
                            {u.name}
                        </Link>
                    </li>
                ))}
            </ul>
        </div>
    )
}


Now clicking:

sunny -> /users2/1
rahul -> /users2/2
priya -> /users2/3

And the UserDetail2 page shows the correct id

*** BONUS: FETCH THE ACTUAL USER ON DETAIL PAGE ***
create UserDetail3.jsx

import { useParams } from "react-router-dom";
import { useState, useEffect } from "react";

export default function UserDetail3() {
    const { id } = useParams();
    const [user, setUser] = useState(null);

    useEffect(() => {
        async function fetchUser() {
            const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
            const data = await res.json();
            setUser(data);
        }

        fetchUser();
    }, [id]);

    if(!user) {
        return <h2>Loading...</h2>
    }

    return (
        <div>
            <h1>User Detail 3</h1>
            <p>Name: {user.name}</p>
            <p>Email: {user.email}</p>
            <p>city: {user.address.city}</p>
        </div>
    )
}

this is now a real detail page
you fetched read data based on URL ID

Now we will move on to :

STEP 3 ---> QUERY PARAMETERS REACT ROUTER v6 (/users?sort=name&limit=10)

=> used in:
  . filters
  . search
  . sorting
  . pagination
  . dashboards
  . admin panels
  . etc...

we will learn how to read and update query params like: /users?search=sunny&sort=name

React Router gives us a hook for this:
  const [searchParams, setSearchparams] = setSearchparams();


Step 3.1 => Basic Query param reading

create a page => src/pages/FilterUsers.jsx

--- code ---

import { useSearchParams } from 'react-router-dom';

export default function Filterusers() {
    const [searchParams] = useSearchParams();

    const search = searchParams.get("search");
    const sort = searchParams.get("sort");

    return (
        <div>
            <h1>Filter Users Page</h1>

            <p>Search: {search}</p>
            <p>Sort: {sort}</p>
        </div>
    )
}

--- code ended ---

app.jsx

--- code ---

import Filterusers from './pages/FilterUsers'
import { BrowserRouter, Routes, Route } from 'react-router-dom'

function App() {
  
  return (
    <>
      <BrowserRouter>
        <Routes>
          <Route path="/filter" element={<Filterusers />}></Route>
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App

--- code ended ---

step 3.2 => setting query params from react (very important)

code:- Usersfilter2.jsx

--- code ---

import { useSearchParams } from "react-router-dom";

export default function FilterUsers2() {
    const [searchParams, setSearchParams] = useSearchParams();

    const search = searchParams.get("search") || "";
    const sort = searchParams.get("sort") || "none";

    function updateSearch(e) {
        setSearchParams( {search: e.target.value, sort} );
    }

    function updateSort(e) {
        setSearchParams( {search, sort: e.target.value} );
    }

    return (
        <div>
            <h1>Filter Users</h1>

            <input
            placeholder="search..."
            value={search}
            onChange={updateSearch}
            />

            <select value={sort} onChange={updateSort}>
                <option value="none">None</option>
                <option value="name">Name</option>
                <option value="city">City</option>
            </select>

            <p><strong>Search:</strong> {search}</p>
            <p><strong>Sort:</strong> {sort}</p>
        </div>
    )
} 

--- code ended ---

Now type in search box --> URL updates 
Change sort --> URL updates

Example:
  ?search=sun&sort=name

why this is powerful:
  . Because the URL becomes the single source of truth
  so:
    . page reload --> state is preserved
    . Sharing URL to someone --> they see same filters
    . Browser back/forward works perfectly
    . No extra state management required
    . This is how modern apps like amazon, flipkart, youtube manage filters.

Step 3.3 => Real example: Filter an API List by Query params
  => let's make it real

--- code ---

import { useSearchParams } from "react-router-dom";
import { useEffect, useState } from "react";

export default function FilterUsers3() {

    const [searchParams, SetSearchParams] = useSearchParams();
    const [users, setUsers] = useState([]);

    const search = searchParams.get('search') || "";

    useEffect(() => {
        async function fetchUsers() {
            const res = await fetch("https://jsonplaceholder.typicode.com/users");
            const data = await res.json();

            const filtered = data.filter( u => 
                u.name.toLowerCase().inludes(search.toLowerCase())
            );

            setUsers(filtered);
        }

        fetchUsers();
    }, [search]); // runs when search params change


    return(
        <div>
            <h1>Filter User 3</h1>

            <input 
                value={search}
                placeholder="search..."
                onChange={(e) => SetSearchParams({ search: e.target.value})}
            />

            <ul>
                {users.map(u => <li key={u.id}>{u.name}</li>)}
            </ul>
        </div>
    )
}

--- code ended ---

* when user types => URL updates
* URL update trigger API filtering
* UI updates automatically

This is exact real-world logic used in:

  . search bars
  . dashboard filters
  . E-commerce product filters
  . Admin CRUD apps

Step 3.4 ---> important notes
  . Query params differ from dynamic params

  Dynamic route:
    . /users/5

  Query params:
    . /users?id=5

  . when to use dynamic params?
    . when ID identifies a SINGLE resource
    . Example: /product/23, /blog/react-hooks

  . when to use Query params?
    . when values are optional
    . when multiple filters must coexist
    . when you need URL persistance
    . Example: /products?category=mobiles&sort=price 

------------- STEP 4: NESTED ROUTES(PROFESSIONAL APP STRUCTURE) --------------

=> nested routes are used in every modern web app:

  . Admin dashboards
  . Profile pages
  . Product pages with tab
  . setting pages
  . layout with sidebar + content
  . multi-layout apps

=> you must master nested routes to build real full-stack frontends.

create: ./src/pages/Dashboard.jsx

--- code ---

import { Link, Outlet } from "react-router-dom";

export default function Dashboard() {
    return (
        <div style={{ display: "flex", gap: "20px"}}>

            {/* Sidebar */}
            <nav style={{ width: "200px", background: "eee", padding: "10px" }}>
                <h3>Dashboard Menu</h3>

                <ul>
                    <li>
                        <Link to="profile">Profile</Link>
                    </li>
                    <li>
                        <Link to="settings">Settings</Link>
                    </li>
                    <li>
                        <Link to="reports">Reports</Link>
                    </li>
                </ul>
            </nav>

            {/* Content-area */}
            <div style={{ flex: 1, padding: "10px"}}>
                <Outlet />
                {/* This loads child routes content */}
            </div>
        </div>
    )
}

--- code ended ---

*** key concept ***

<Outlet /> => means => "Show the child route here"

Dashboard becomes a layout

Step 4.2 --> create child pages

Profile.jsx

export default function Profile() {
  return <h1>User Profile</h1>;
}

Settings.jsx

export default function Profile() {
  return <h1>Settings Page</h1>;
}

Reports.jsx

export default function Profile() {
  return <h1>Reports Page</h1>;
}

Step 4.3 --> Add Nested Routes in App.jsx

--- code ---

import Filterusers from './pages/FilterUsers'
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import FilterUsers2 from './pages/FilterUsers2'
import FilterUsers3 from './pages/FilterUsers3'
import Dashboard from './pages/Dashboard'
import Profile from './pages/Profile'
import Settings from './pages/Settings'
import Reports from './pages/Reports'
import NotFound from './pages/NotFound'

function App() {
  
  return (
    <>
      {/* Query params */}

      {/* <BrowserRouter>
        <Routes>
          <Route path="/filter" element={<Filterusers />}></Route>
          <Route path="/filter2" element={<FilterUsers2 />}></Route>
          <Route path="/filter3" element={<FilterUsers3 />}></Route>
        </Routes>
      </BrowserRouter> */}

      {/* Nested Dashboard Routes */}
      <BrowserRouter>
        <Routes>
          <Route path='dashboard' element={ <Dashboard /> }>
            <Route path='profile' element={ <Profile /> }></Route>
            <Route path='settings' element={ <Settings /> }></Route>
            <Route path='reports' element={ <Reports /> }></Route>
          </Route>

          <Route path='*' element={ <NotFound /> }></Route>
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App


--- code ended ---

*** Notice something important => child routes DO NOT start with '/' .

correct:

profile
settings
reports

incorrect:

/profile

Step 4.4 --> Test in Browser

/dashboard
/dashboard/profile
/dashboard/settings
/dashboard/reports

Sidebar stays 
content changes
layout is consistent
No page refresh

You just build a real dashboard structure

. WHY NESTED ROUTES MATTERS?

because real apps are not simple.
  Real Systems use nested UI components like:
    Dashboard
      ├── Profile
      ├── Settings
      └── Orders
          ├── Order List
          └── Order Detail




React router handles this beautifully.

*** OPTIONAL BONUS ---> default child route ***

=> inside dashboard route:

<Route index element={<Profile />} /> 

Now:
/dashboard shows -> profile

EXTRA BONUS --> Dynamic Nested Routes
Example: /dashboard/orders/22
Route:
<Route path="orders/:orderId" element={<OrderDetail />} />

Step 4 done => you now understand
. Layouts
. Nested routes
. Sidebars
. Child routing
. <Outlet />
. Real Dashboard architectures

This is mid level frontend developer skill


---------------- STEP 5 --> PROTECTED ROUTES (AUTHENTICATION REQUIRED) -----------------

=> React router does not have built in auth -> so we have to build it manually.

This is Used in Every real App:
  . Dashboard
  . Profile page
  . Admin panel
  . Orders Page
  . Payment Page
  . User settings
  . Anything behind login

  => React router does not provide built-in authentication, so real developers build protected routes manually.

  => the pattern i will learn here is used in real companies.


  WHAT WE WILL bUILD 

  1. AuthContext -> stores user login status
  2. Login Page -> sets logged in user 
  3. ProtectedRoute -> Wrapper that blocks page
  4. Redirect user to login if NOT authenticated
  5. Access dashboard ONLY after login

This is same flow used in :

. MERN apps
. Next.js apps
. Firebase apps
. Token-based authentication












